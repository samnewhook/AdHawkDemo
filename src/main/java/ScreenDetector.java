import org.bytedeco.javacpp.indexer.Indexer;
import org.bytedeco.javacpp.opencv_core;
import org.bytedeco.javacv.CanvasFrame;
import org.bytedeco.javacv.Java2DFrameConverter;
import org.bytedeco.javacv.OpenCVFrameConverter;

import javax.imageio.ImageIO;
import javax.swing.*;
import java.awt.*;
import java.awt.image.BufferedImage;
import java.io.File;
import java.io.IOException;

import static org.bytedeco.javacpp.opencv_core.*;
import static org.bytedeco.javacpp.opencv_video.estimateRigidTransform;

/**
 * Screen Detector class for handling the detection of a screen in an image.
 */
public class ScreenDetector {
    public static void main(String[] args) {
        if (args.length < 2 || args.length > 2) {
            System.out.println("Screen Detector is a demonstration program for showing the estimation" +
                    " of an eye position to its corresponding screen position. The program will display" +
                    " the position of the original estimated eye position on the first image and the" +
                    " position of the transformed eye position on the second image. Some assumptions" +
                    " for this program are that the first image is a static image of the screen of a" +
                    " device calibrated using a second program (Using custom icons displayed in the corners" +
                    " of the device screen and using a distance capture device to align the system in the" +
                    " beginning). After having the initial position of the screen with respect to the head," +
                    " this program would take any other Vector generated by the eye tracking software and" +
                    " transform it using the estimate rigid transform function to get an affine transform" +
                    " matrix and apply it using the perspectiveTransform function (both from openCV). \n" +
                    "Arg 1: Calibrated Image name (found in source dir)\n" +
                    "Arg 2: Picture taken from camera at the time an eye tracking vector is made.");
        }
        final String picDir = System.getProperty("user.dir") + "\\src\\main\\resources\\SourceImages\\";
        System.out.println(System.getProperty("user.dir") + "/../resources/SourceImages/");
        File calibrationPic = new File(picDir + args[0]);
        File transformedPic = new File(picDir + args[1]);
        try {
            //Load Images
            BufferedImage bufferedImage = ImageIO.read(calibrationPic);
            BufferedImage maskImage = ImageIO.read(transformedPic);
            opencv_core.Mat matrix1 = new OpenCVFrameConverter.ToMat().convert(new Java2DFrameConverter().convert(maskImage));
            opencv_core.Mat matrix2 = new OpenCVFrameConverter.ToMat().convert(new Java2DFrameConverter().convert(bufferedImage));
            //Use function to estimate the affine transform from matrix1 to matrix2
            Mat affineMat = estimateRigidTransform(matrix1, matrix2, true);

            //Create a random Eye Vector
            EyeVector ev = EyeVector.createRandomVector();
            Mat eyeVector = ev.getMatFromVector(matrix1.cols(), matrix1.rows());

            //Add [0 0 1] to affine matrix to make it compatible with perspective transform.
            Mat affineMat2 = transformAffineMatrix(affineMat);

            //Add the original estimated EyeVector to the original image
            addPointsToMat(eyeVector, matrix1);

            System.out.println("Pre Transform:");
            printAllValues(eyeVector);

            //Transform the eyeVector point to the new point defined by the transform estimated earlier.
            perspectiveTransform(eyeVector, eyeVector, affineMat2);

            System.out.println("Post Transform:");
            printAllValues(eyeVector);

            //Add the new points to the second image
            addPointsToMat(eyeVector, matrix2);
        } catch (IOException e) {
            e.printStackTrace();
        }
    }

    /**Transforms the unusable affine matrix produced by estimateRigidTransform to a usable one
     * by adding [0 0 1] to the bottom of the matrix.
     * @param affineMat Input Affine Transform Matrix
     * @return Formatted Matrix.
     */
    private static Mat transformAffineMatrix(Mat affineMat) {
        Mat affineMat2 = new Mat(3, 3, CV_64FC1);
        Indexer affineMatIndexer = affineMat.createIndexer();
        Indexer affineMat2Indexer = affineMat2.createIndexer();
        for (int i = 0; i < affineMat.rows(); i++) {
            for (int j = 0; j < affineMat.cols(); j++) {
                for (int k = 0; k < affineMat.channels(); k++) {
                    affineMat2Indexer.putDouble(new long[]{i, j, k},
                            affineMatIndexer.getDouble(i, j, k));
                }
            }
        }
        affineMat2Indexer.putDouble(new long[]{2, 2, 0}, 1.0);
        return affineMat2;
    }

    /**Adds points to a mat
     * @param pts Points to be added.
     * @param matrix Matrix for points to be added to.
     * @return Matrix with points added.
     */
    private static Mat addPointsToMat(Mat pts, Mat matrix) {
        double x = 0;
        double y = 0;
        Indexer indexer = pts.createIndexer();
        Indexer matIndexer = matrix.createIndexer();
        Mat cpyMat = matrix.clone();
        for (int i = 0; i < pts.cols(); i++) {
            for (int j = 0; j < pts.rows(); j++) {
                for(int k = 0; k < pts.channels(); k++) {
                    if (k == 0){
                        x = indexer.getDouble(i, j, k);
                    } else {
                        y = indexer.getDouble(i, j, k);
                    }
                }
                for (int l = 0; l < 7; l++){
                    for (int m = 0; m < 7; m++) {
                        try {
                            matIndexer.putDouble(new long[]{(long) x + (-4 + l),
                                    (long) y + (-4 + m)}, 255.0);
                        } catch(Exception e) {
                            e.printStackTrace();
                        }
                    }
                }
            }
        }
        absdiff(matrix, cpyMat, cpyMat);
        addWeighted(matrix, 0.2, cpyMat, 0.8, 0, cpyMat);
        showImage(cpyMat);
        return cpyMat;
    }

    /**Displays the Image
     * @param matrix Image to be displayed.
     */
    private static void showImage(Mat matrix) {
        CanvasFrame canvasFrame = new CanvasFrame("Screen Detector", 1);
        canvasFrame.setDefaultCloseOperation(WindowConstants.EXIT_ON_CLOSE);
        canvasFrame.setCanvasSize(1920, 1440);
        Canvas canvas = canvasFrame.getCanvas();
        canvasFrame.getContentPane().removeAll();
        ScrollPane scrollPane = new ScrollPane();
        scrollPane.add(canvas);
        canvasFrame.add(scrollPane);
        canvasFrame.showImage(new OpenCVFrameConverter.ToMat().convert(matrix));
    }

    /**Prints all values in a given matrix.
     * @param mat Matrix to be printed.
     */
    private static void printAllValues(Mat mat) {
        Indexer printer = mat.createIndexer();
        for (int i = 0; i < mat.cols(); i++) {
            for (int j = 0; j < mat.rows(); j++) {
                for (int k = 0; k < mat.channels(); k++) {
                    System.out.println(printer.getDouble(i, j, k));
                }
            }
        }
    }
}
